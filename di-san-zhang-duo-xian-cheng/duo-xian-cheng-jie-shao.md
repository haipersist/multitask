# 多线程介绍

#### 线程介绍

在第二章中介绍了多进程，进程是资源分配的基本单元，但系统调度的最小单位是线程，也叫做轻量级进程。当我们运行一个应用程序时，真正执行代码逻辑的就是线程，可以叫做主线程。线程会有自己的线程ID，线程栈，程序计数器等。通常，线程主要包括内核线程和用户线程两种。内核线程是属于操作系统负责管理的，用户线程对于内核来说是无感知的。

通过主线程可以创建多个其他的线程，被称作对等线程。多个线程会在单个进程内执行，线程会使用同一个虚拟地址空间，即同样的资源。因为线程之间是可以实现资源共享的。

和进程一样，线程同样具备不同的状态，在JAVA中，指定了6种状态，包括初始化，运行，阻塞，等待，超时等待以及终止。

#### 多线程介绍

和多进程一样，多线程存在的目的也是提高资源利用率，但相比于多进程，多线程的资源消耗要更小，因为尽管也有上下文切换，但线程上下文切换所使用的资源要远远小于进程上下文切换。计算机在执行任务时，真正执行任务的是线程，就算是多进程，每个进程执行的任务仍然是线程，只是这时只有单线程。很多地方都会问到线程和进程的区别，一句话概括就是进程时资源分配的基本单元，线程是CPU调度的基本单元。

然而多线程同样存在一定的风险，上面已经提到过多线程可以共享进程内变量，这引出了一个问题，即线程安全性。在多个线程同时操作同一变量，如何保证其执行结果的可遇见性是具备一定挑战的。为了实现线程安全，有很多的实现机制，尤其是JAVA，实现了多种不同的线程同步机制，通信方式等。从volatile变量定义禁止重排序保证可预见性，到final的定义，再到synchronized原生锁，以及后续版本的演进升级，再到JAVA线程池和Executor，再到并发包种的多种Lock(ReentrantLock,读写锁等等），再到ForkJoin/Pool，Sephmare,CountDownLatch，还有就是Java的并容器.

包括ConcurrentHashMap,CopyOnWriteArrayList,阻塞队列等等。总之，JAVA在多线程方面所作的努力要远远高于其他语言。

学习多线程，一定是要学习JAVA多线程的，因为JAVA对多线程的使用非常得成熟，对于多线程的管理，线程池的使用，线程安全性，优先级等方面，JAVA都有比较深入的研究和成熟的成果。不过还有一点要明白，JAVA多线程也是最终创建操作系统的内核线程来实现的。

总结JAVA的使用，为了保证线程安全性，可以分为两大类，一个就是悲观互斥锁，通过内置的synchronized种的重量级锁，其他的基本上都是借助于volatile，CAS，AQS（同步队列）来实现的。

再说几个线程相关的现象。

线程饥饿：线程饥饿是指由于某个线程长时间的占用，而不释放，导致其他线程永远得不到执行。通常只要通过设置线程的超时时间即可。

线程死锁：这个比较好理解了，和第二章介绍的多进程死锁是一个意思，即因为相互抢占资源，互相等待的场景。

线程活锁：活锁和死锁是完全相反的。活锁的主要现象是不同线程相互推脱责任，谁也不执行，导致整体任务进行不下去。简单说就是相互谦让。

线程需要考虑的几大方面：

如何提高效率；

如何保证线程安全性；

如何实现线程通信；

linux中在之前的版本中并不支持多线程，后来是引入了用户级的线程，通常称为轻量级进程，在2.6版本之后才真正支持内核级线程。
