# 2、多任务的发展历史

**单任务处理**

&#x20;      最早的计算机是一种单任务处理的逻辑。如果有了解过计算机历史的应该可以知道，第一代计算机虽然是一个庞然大物，但其最初设计的初衷就是做一些数据运算，本身的运算能力不是很强，每秒的运算能力也不强。当时想要计算机执行我们想要的某些任务，其基本流程是首先将指令打到卡片上，然后放到计算机里面执行，俗称穿孔打卡编程。卡片类似如下：

![v2-08616d84dbb373b459a646da01d7e7c8\_720w](<../.gitbook/assets/0 (1)>)

看这图片，最早的还不是二进制，是10进制的。

这种运行方式，就是每次把任务放到计算机里面执行。虽然当时的计算机执行效率相对于现在不高，但是在当时相对于人的计算是非常可观的。当时也是为了美国进行弹道计算而产生的。

由于最早的计算机本身没有存储功能，因此在输入输出端会浪费大量的时间，计算机大部分时间是空闲的。所以整体下来，单任务处理还是太慢了，随着对计算机要求的提高，其已经完全不满足需求了。

**单道批量处理**

&#x20;     单任务处理效率过于低下，因此后来的计算机，即第二代计算机，出现了批量处理任务。

批量处理任务是将一个一个任务进行合并，然后一起放到计算机里进行执行。计算机拿到任务后，会按照顺序一个一个地执行。

&#x20;     相对于第一种，批量处理的效率大大提高了，减少了输入输出端的操作。可是虽然这些任务是批量的，但是却一直是顺序执行的。就算前面的任务阻塞了，后面的任务也必须要等到前面的任务执行完毕才可以开始执行。因此，其整体性能还是有很大的瓶颈。

&#x20;    随着集成电路和操作系统的出现，迎来了第三代计算机，也迎来了多道程序处理。

**多道程序处理**

&#x20;      针对于串行批量任务处理任务的这种做法，

&#x20;      随着第三代计算机的兴起，计算机在硬件和软件上都有了革命性的变化。硬件上引入了集成电路，软件上引入了操作系统。在硬件上，计算机每秒的计算能力更强，在操作系统中，内核通过某种策略，保证不同的进程可以切换，从而最大程度利用计算机的资源。比如当某个程序遇到阻塞了，CPU完全可以将该程序挂起，并调度其他就绪的进程执行，当执行完之后，就会再执行其他程序。当然这其中涉及到CPU的调度程序、调度算法等等，还是比较复杂的。上面说的例子也只是非抢占式任务，其实还有抢占式任务，可能就涉及到时间片轮转、中断等等概念。

&#x20;     此外，如果计算机是多核CPU，在不同处理器上的程序，完全可以并行执行。这个核上面所讲到的并发还不是完全相同的概念。并行可以保证不同处理器同时执行不同的任务；而迸发强调的是在单个处理器上，任务在不停地切换，从而保证程序可以迸发的执行。本质上，处理器同时只能处理一个任务。
