# 多进程原理

&#x20;      我们在运行程序时，会感觉正在独占操作系统资源和硬件。而实际上，在整个过程中，还有很多其他的进程和当前进程一样正在执行，只是系统会根据调度算法来对不同的进程调度来实现进程的并发和并行。并发就是指单个处理器下多个进程交替地执行；而并行是不同进程分别在不同的处理器上执行。而这也是多进程编程的基本原理。

本文只说并发。不同进程交替地执行，这其中就涉及到进程的运行、暂停、再运行等等。因此对于每一个进程，都会存在以下几个状态：就绪、运行、阻塞等等。

2.1 进程的状态

1、就绪

进程本身已经准备好了运行需要的所有资源，就等着操作系统调度CPU来处理了。就绪状态在两种情况会出现，一是刚创建好的进程；二是因为当前CPU执行时间到（比如时间片执行完了）。

2、运行

比较好理解，进程拿到了CPU资源，处理器正在执行该进程。

3、阻塞

当正在执行的进程运行期间，由于出现阻塞，比如IO阻塞需要等待数据到达，此时进程会主动向系统发出申请将自己由运行状态变为阻塞状态，处于阻塞状态的进程是不占用CPU资源的。

下面是比较常见的状态转换过程：

1）就绪态——运行态：对就绪状态的进程，当系统为其分配了CPU来处理，该进程会从就绪状态变为运行状态；\
2）运行态——阻塞态：正在运行的进程由于发生某等待事件而无法执行，则进程由运行状态变为阻塞状态，最常见的是IO阻塞，比如网络IO、磁盘IO等等；\
3）阻塞态——就绪态：处于阻塞状态的进程，如果等待事件已经完成，比如数据已经准备i完成，处于阻塞状态的进程并不会立刻转入运行状态，而是先转入就绪状态，因为此时可能还没有CPU资源来处理，需要等待系统为其分配CPU来处理；\
4）运行态——就绪态：正在运行的进程，由于为其调度的资源要被回收了，该进程便由执行状态转变为就绪状态。

**进程上下文切换**

从上面的进程状态的变化可以看到进程可能会由于分配的CPU资源用完了或者出现了IO阻塞等原因导致执行的进程由当前CPU处理的进程切换成另外的进程。进程间的切换也叫做进程的上下文切换。

在具体说进程上下文切换之前，要搞懂啥是上下文切换。计算机系统中发生上下文切换的场景非常多，比如系统调用上下文切换、中断上下文切换，进程上下文切换，线程上下文切换等等。简单来说，上下文切换即保存当前执行所需的上下文，然后切换到新的上下文。我们先了解一下系统调用引起的上下文切换。

上面已经提到，一个进程包括用户空间和内核空间。处于内核空间时可以访问任何硬件资源；而处于用户空间的进程访问资源是受限的。所以程序执行时，经常会发生系统调用，比如我们进行磁盘文件的读写，网络数据的读写等等。而在发生系统调用的过程中，由于需要从用户态切换到内核态，执行之后还需要从内核态切换回用户态，因此需要经历两次的上下文切换。上下文切换主要会做如下操作:

1. 保存 CPU 寄存器里原来用户态的指令位\
   2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。\
   3、跳转到内核态运行内核任务。\
   4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。

说完系统调用，再回到我们的进程上下文切换。进程的上下文切换要比系统调用复杂得多，因为系统调用是在进程内完成的。而进程的上下文切换需要涉及到两个进程。切换是由操作系统内核完成的，即需要从进程的内核态切换到另外一个进程的内核态。因此CPU在完成切换时，不仅要保存当前程序计数器和寄存器等内容，还要保存用户空间资源。待切换到新的进程后，还要刷新当前的虚拟内存。因此，进程的上下文切换是成本比较高的一种切换场景。

下面这张示意图大致展示了进程切换时所做的工作。

![pastedImage](../.gitbook/assets/7)

**看到上面的例子，你应该可以清楚，多进程并不是越多越好。因为进程的创建本身也是一种消耗，需要系统为其分配资源，分配完整的虚拟地址空间；此外，进程间的切换也是比较耗时的过程。**

**进程间通信（IPC）**

由于进程具备独立的虚拟地址空间，因此不同进程的资源是无法做到共享的。如果想实现进程间的通信，必须要借助某种渠道。目前比较通用的进程间通信方式有：消息队列、信号、信号量、管道、命名管道、共享内存等等。

**消息队列**

消息队列，这个在平时并不少见。我们经常会用Redis,RocketMQ,Kafka等作为消息队列。操作系统中的消息队列大体和我们所见的比较相似，但其最大的特点是消息队列是存储在内核中的一种消息链表，是操作系统自身提供的一种功能。

不同的进程可以向消息队列中写入数据，接收进程异步地接收消息，其并不会因为消息为空出现阻塞。在linux中可以通过msgget创建消息队列，并通过msgsend,msgrecv发送和接收消息。

**管道/命名管道**

管道相对于命名管道也叫匿名管道。如果接触过零拷贝，会经常看到管道的技术。

匿名管道（父子进程）：

grep -rl "xiaomi" | wc -l

命名管道：

mkfifo namedpipe

echo "xiaomiyoupin" > namedpipe

另一个进程：

cat namedpipe

**信号**

在Linux中，信号随处可见，比如我们常见的kill进程 .kill -9,，几乎大家都会用到。其他常见的信号主要包括如下：

（1）SIGHUP：用户终端退出时，同一Session下的进程都会收到该信号，并终止。\
（2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号，也就是改信号只能关闭前台进程。\
（3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\\键将产生该信号。\
（4）SIGBUS和SIGSEGV：进程访问非法地址。\
（5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。\
（6）SIGKILL：用户终止进程执行信号。执行kill -9会发送该信号给目标进程。\
（7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号，相对于SIGKILL，该信号可以被进程捕获，因此收到该信号后，进程不会直接默认强制退出，而是可以执行一些处理程序，比如关闭文件等等。\
（8）SIGALRM：定时器信号。\
（9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。

**信号量**

Semaphore，这个学JAVA的肯定比较熟悉，信号量在JAVA中主要用来实现线程同步机制上。在操作系统中，其可以用来进行进程间通信，主要是控制资源的访问和进程同步。信号量控制了资源的访问数量。其是一个计数器，值为非负整数。当减到0时，证明没有资源了。如果进程要访问资源时，会将该信号量的值减去1，如果减到0了，就会进入到等待队列。专业术语上，有两个操作P，V，一个是减1，一个是+1。通过信号量可以实现进程间的同步，这个和线程间的信号量同步是一个概念。

**共享内存**

这个就比较好理解了，类似于我们使用分布式缓存，找到一个公共内存，实现内存的共享，从而实现进程间的通信。比如mmap，可以将多个进程的虚拟地址空间的部分映射到同一块内存空间上。在这种情况下，其中一个进程改变了共享内存的内容，另外一个进程也会感知到。这个也被人们称作写时复制，Copy on Write。

既然多进程之间使用了共享内存，那就存在同时修改变量的问题，也就是同步和互斥的问题。同一时刻，只能有一个进程修改对应变量。要实现目的通常我们会加上锁，比如互斥所。但加锁非常容易引起一个常见的问题：死锁。在上学时考试以及应聘的笔试可能都会提到死锁，即死锁的产生条件。互斥、持有并等待、无抢占以及循环等待这四个条件。在开发中，要注意避免死锁的产生。

#### Linux多进程

在Linux中，所有进程构成了一个树形结构。树根是系统自动构造的，即在内核态下执行的0号进程，它是所有进程的祖先。

由0号进程创建1号进程（内核态），1号进程是开机时，内核调用的初始化进程-init。该进程负责准备操作环境，启动各种服务，执行rc.local等初始化文件。

ps ajxf    查看进程树

Ps命令是在日常工作中使用比较频繁的命令，通过该命令可以查看正在运行的进程，查看端口、查看父子进程等等。

如果查看TCP端口可以使用netstat命令。

```shell
PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND
1 28716 28716 28716 ? -1 Ss 0 11:04 /srv/dailyblog/env/bin/python /srv/dailyblog/env/bin/supervisord -c supervisor.conf
28716 30684 30684 28716 ? -1 S 0 4:43 \_ /srv/dailyblog/env/bin/python /srv/dailyblog/env/bin/celery -A dailyblog worker --loglevel=INFO
30684 30690 30684 28716 ? -1 S 0 0:00 | \_ /srv/dailyblog/env/bin/python /srv/dailyblog/env/bin/celery -A dailyblog worker --loglevel=INFO
28716 24372 24372 28716 ? -1 S 0 0:07 \_ /srv/dailyblog/env/bin/python /srv/dailyblog/env/bin/gunicorn dailyblog.wsgi:application -c /srv/dailyblog/www/
24372 24377 24372 28716 ? -1 Sl 0 0:14 \_ /srv/dailyblog/env/bin/python /srv/dailyblog/env/bin/gunicorn dailyblog.wsgi:application -c /srv/dailyblog/
24372 24380 24372 28716 ? -1 Sl 0 0:18 \_ /srv/dailyblog/env/bin/python /srv/dailyblog/env/bin/gunicorn dailyblog.wsgi:application -c /srv/dailyblog/
24372 24383 24372 28716 ? -1 Sl 0 0:19 \_ /srv/dailyblog/env/bin/python /srv/dailyblog/env/bin/gunicorn dailyblog.wsgi:application -c /srv/dailyblog/
24372 24384 24372 28716 ? -1 Sl 0 0:25 \_ /srv/dailyblog/env/bin/python /srv/dailyblog/env/bin/gunicorn dailyblog.wsgi:application -c /srv/dailyblog/ell
```

除了0号和1号进程，其他进程都是通过fork创建的。即进程调用进程是先通过父进程以fork的方式复制一个与父进程相同的暂存进程，然后暂存进程开始以exec的方式加载实际要执行的程序。这也是我们进行多进程编程的方式。fork子进程之后，父进程会将当前虚拟地址空间的数据资源复制一份给子进程，但此时父进程和子进程使用的物理空间可能还是一份，只有当其中的父进程或者子进程进行了数据的修改，子进程才会拥有完全独立的数据。

下面是Linux下多进程编程的简单展示：

<pre class="language-c"><code class="lang-c">#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#include &#x3C;unistd.h>
int main()
{
   printf("+++process %d start running!ppid = %d\n",getpid(),getppid());
    pid_t pid = fork();
    if(pid)//父进程
{
<strong>  printf("parent:process %d start running!ppid = %d\n",getpid(),getppid());
</strong>  //do something
  //...
}
else//子进程
{
  printf("child:process %d start running!ppid = %d\n",getpid(),getppid());
  //do something
  //...
exit(0);
}
exit(0);
}</code></pre>
