# 进程介绍

在介绍多进程之前，首先是要了解什么是进程，主要是用来做什么的？它是由什么组成的？

进程是操作系统中的一个重要概念，当某一个应用程序被加载到内存中运行了，那么就可以称之为进程。注意这里的重点一是应用程序，二是运行中。对于一个应用程序，只有在操作系统中运行了，才可以称为进程，进程是操作系统赋予程序的生命。

在Linux种，可以用ps或者top 来查看当前系统中的进程。例如：

![](<../.gitbook/assets/5 (1)>)

其中pid表示的就是进程id（Process Id)。操作系统会为每一个进程分配一个唯一的id。

在一台计算机内，可以运行多个不同的进程，而进程与进程之间是完全相互隔离的，互不干扰。而这要得益于操作系统的资源分配机制。操作系统为每一个进程都会分配一个独立的虚拟地址空间，其中包括内核空间和用户空间。也就是说，进程是系统资源分配的最小单元，每一个进程都有一个完整的虚拟地址空间。下面就介绍一下虚拟地址空间。

1.2 虚拟地址空间

提到虚拟地址空间，不得不说其产生的背景。在早期的计算机中，程序要运行是直接加载到物理内存中的，它会提前分配绝对物理地址，然后加载执行，比如我们早期使用的手机，像小灵通等等。这种运行方式带来的问题有很多。一是当时的物理内存都比较小，基本上运行几个程序，基本上内存就满了；二是物理地址不隔离，这就导致非常容易出现程序被某些恶意的程序篡改；三是由于物理地址是提前分配一段连续的地址，所以非常可能出现碎片，即某些空闲的地址，这就造成了内存使用效率非常低，无法充分利用内存。本来内存就很小，还有碎片，实在是无法忍受。

针对上述的问题，后续衍生除了覆盖和交换技术。

覆盖：将程序自身按照功能划分出多个模块，然后将不可能同时运行的模块共享一块内存空间；

交换：即将内存和外存交换，将暂时不用的内存数据移动到外存设备中；

虽然这两种技术在一定程度上解决了内存的使用问题，但是由于其本身存在天然的复杂性（覆盖技术需要开发者自己划分模块），此外也并不能解决地址隔离的问题。基于此，虚拟内存技术应运而生。这就是虚拟地址空间产生的背景。

虚拟存储就是同时利用内存和外存一起实现的一种方式。在进程执行时，会将暂时不需要的程序或数据放在内存外，在需要时通过缺页异常获取数据。具体在我写的操作系统内存管理有提到这个，可以参考我之前写的文章： https://hbnnforever.cn/article/osmemorysh.html。

虚拟地址空间是连续的，大小是固定的，对于32位操作系统，会分配2^32，即4GB的空间；对于64位操作系统，则会分配2^64。而一个虚拟地址空间由内核空间和用户空间组成，比例为1:3。最上面的内核空间是预留给操作系统中的代码和数据的，每一个进程都是相同的。底部的用户空间用来存放用户进程定义的代码和数据，主要包括：

1、栈

编译器栈来完成函数调用，其在程序执行期间会动态地扩展和收缩。当我们调用函数时，栈会增长，每当函数返回时，栈就会收缩。它是向下增长的，且是连续的。栈由操作系统控制，和开发者无关。这里的栈和JAVA栈不是一个，但JAVA栈会使用进程的栈。

2、堆

堆是在程序运行时是由malloc创建的，学过C语言的应该都用过。堆可以在运行中动态地扩展或收缩。它是向上增长的，且不是连续的。要注意，这里的堆和JAVA堆是不同的。JAVA堆最后会利用进程的堆，但进程的堆并不仅仅是JAVA堆，其中的直接内存其实使用的也是进程的堆。

JAVA

3、程序代码和数据

代码是从以固定地址开始的，然后是数据段，存储全局变量。代码和数据区是直接初始化的，大小固定。

下面是一张比较标准的虚拟地址空间示意图（来自深入理解计算机系统）：

![](../.gitbook/assets/6)

通常将进程称作PCB，即进程控制块。操作系统在内核空间维护了一张表，叫进程表。进程表记录了当前操作系统的进程信息，包括进程ID，进程优先级，进程状态以及指向进程的指针等等。对于任何一个进程，它都会存在上述的完整的虚拟地址空间。通过虚拟地址空间，操作系统可以对进程更灵活、更友好的管理。
